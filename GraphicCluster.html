<!DOCTYPE html>
<html>
    <body>
        <script>
        var singlesArray = [
            {jobType: 'inspection'},
            {jobType: 'inspection'},
            {jobType: 'inspection'},
            {jobType: 'maintinance'},
            {jobType: 'maintinance'},
            {jobType: 'maintinance'},
            {jobType: 'maintinance'},
            {jobType: 'maintinance'},
            {jobType: 'wellServices'},
            {jobType: 'wellServices'},
            {jobType: 'fieldService'}
        ];
        
        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        var svgNS = svg.namespaceURI;
        
        //#e8355c, #f2b318, #92b264, #4480ac
        function classifySingles(singles){
            var classification = {};
            for(var i=0; i<singles.length; i++){
                for(var key in singles[i]){
                  if(classification[singles[i][key]]===undefined){
                        classification[singles[i][key]] = 1
                  } else {
                        classification[singles[i][key]] = classification[singles[i][key]]+1;
                  }
                }
            }
            console.log(classification);
            return classification;
        }

        function setupClusterCircles(classificationObjects){
            
            var clusterCircles = [];
            var sizes = ['XLarge','large','medium','small'];

            for(var k in classificationObjects){
                clusterCircles.push({
                    'type': k,
                    'count': classificationObjects[k],
                    'size': sizes[Math.floor(Math.random()*sizes.length)]
                });
            }

            return clusterCircles;
        }

        function positioning(postion, x, y, m, r) {
            switch (postion) {
                case 0:
                    return {x: x + m + r, y: y - m - r}
                    break;
                case 1:
                    return {x: x - m - r, y: y - m - r}
                    break;
                case 2:
                    return {x: x - m - r, y: y + m + r}
                    break;
                case 3:
                    return {x: x + m + r, y: y + m + r}
                    break;
                default:
                    return {x: x , y: r}
                    break;
            }
        }

        function createGraphic(singles, height, width){
            this.height = height;
            this.width = width;

            var orginX = this.width/2;
            var orginY = this.height/2;

            var motherCircleRadius = 5;
            var margin = 3;

            var radiusSize = {'XLarge': (height/2)*.45, 'large': (height/2)*.40, 'medium':(height/2)*.35,'small':(height/2)*.30};
            var colorType = {'fieldService': '#f2b318', 'inspection': '#4480ac', 'maintinance': '#92b264','wellServices':'#e8355c'};
            
            var XLarge = (height/2)*.45;
            var large = (height/2)*.40;
            var medium = (height/2)*.35;
            var small = (height/2)*.30;

            var motherCircle  = new Circle(orginX,orginY,motherCircleRadius);
            var circles = [];
            //motherCircle.fill('yellow');

            var clusterCircleProperties = setupClusterCircles(classifySingles(singles));
            for (var i = clusterCircleProperties.length - 1; i >= 0; i--) {
                circles.push( new Circle(   positioning(i,orginX,orginY,margin,radiusSize[clusterCircleProperties[i].size]).x, 
                                            positioning(i,orginX,orginY,margin,radiusSize[clusterCircleProperties[i].size]).y,
                                            radiusSize[clusterCircleProperties[i].size],
                                            colorType[clusterCircleProperties[i].type],
                                            clusterCircleProperties[i].count ));
            }

            console.log(circles);
            //#e8355c, #f2b318, #92b264, #4480ac
            // var upperRight = new Circle(orginX + margin + XLarge, orginY - margin - XLarge, XLarge,'#f2b318');
            // var upperLeft = new  Circle(orginX - margin - small,orginY - margin - small, small,'#4480ac');
            // var lowerLeft = new  Circle(orginX - margin - medium, orginY + margin + medium, medium,'#92b264');
            // var lowerRight = new Circle(orginX + margin + large, orginY + margin + large, large,'#e8355c');

            svg.appendChild(motherCircle.getCircleNode());

            for (var i = circles.length - 1; i >= 0; i--) {
                 svg.appendChild(circles[i].getCircleNode());
                 svg.appendChild(circles[i].connectToMother(motherCircle));

            }
 
        }

        function addSizeProperty(classification){
            null;
        }

        createGraphic(singlesArray, 100,100);

        function Circle(cx,cy,cr,color,label) {

            this.cx = cx;
            this.cy = cy;
            this.cr = cr;
            this.color = color;
            this.label = label;
            this.circle = document.createElementNS(svgNS,'circle');
            this.g = document.createElementNS(svgNS,"g");
            this.label = document.createElementNS(svgNS, 'text');
            //connection nodes
            // For a circle with origin (j, k) and radius r:
            // x(t) = r cos(t) + j
            // y(t) = r sin(t) + k

            this.getConnectionNodes = function(){

                return connectionNodes = [  
                            {name: 'urNode', x: this.cr*Math.cos(Math.PI/4)+this.cx, y:this.cr*Math.sin(Math.PI/4)+this.cy},
                            {name: 'ulNode', x: this.cr*Math.cos(Math.PI*(3/4))+this.cx, y:this.cr*Math.sin(Math.PI*(3/4))+this.cy},
                            {name: 'llNode', x: this.cr*Math.cos(Math.PI*(5/4))+this.cx, y:this.cr*Math.sin(Math.PI*(5/4))+this.cy},
                            {name: 'lrNode', x: this.cr*Math.cos(Math.PI*(7/4))+this.cx, y:this.cr*Math.sin(Math.PI*(7/4))+this.cy}
                                        ];
            } 


            this.constractCircle = function(){
                this.circle.setAttribute('cx', cx);
                this.circle.setAttribute('cy', cy);
                this.circle.setAttribute('r', cr);
                this.circle.setAttribute("stroke", this.color);
                this.circle.setAttribute("stroke-width", 2);
                this.circle.setAttribute('fill', this.color);
                this.circle.setAttribute('fill-opacity', 0.4);

                this.label.setAttribute('x', cx);
                this.label.setAttribute('y', cy);
                this.label.setAttribute('fill', '#000');
                this.label.setAttribute('dx', '-1.5%');
                this.label.setAttribute('dy', '3%');
                this.label.setAttribute('font-family', 'Arial');

                this.label.textContent = label;

                this.circle.addEventListener('mouseover', function(e) {
                e.currentTarget.setAttribute('stroke-width', 3);
                });

                this.circle.addEventListener('mouseleave', function(e) {
                e.currentTarget.setAttribute('stroke-width', 2);
                });

                this.g.appendChild(this.circle);
                this.g.appendChild(this.label);
            }

            this.getX = function(){
                return this.cx;
            };

            this.getY = function(){
                return this.cy;
            };

            this.getR = function(){
                return this.cr;
            };

            this.location = function(){

            }

            this.getCircleNode = function() {
                this.constractCircle();
                return this.g;
            };

            this.fill = function(color) {
                this.circle.setAttribute('fill', color);
            };

            this.connectToMother = function(mother){
                    var connection = document.createElementNS(svgNS,'line');
                    var connectionNodes = this.getConnectionNodes();
                    var motherConnectionNodes = mother.getConnectionNodes();
                    var a, b, distance, shortestDistance = 1000; 

                    for (var i = motherConnectionNodes.length - 1; i >= 0; i--) {
                        for (var j = connectionNodes.length - 1; j >= 0; j--) {
                             a = motherConnectionNodes[i].x - connectionNodes[j].x;
                             b = motherConnectionNodes[i].y - connectionNodes[j].y;
                             distance = Math.sqrt( a*a + b*b );
                    
                             if(distance <= shortestDistance){
                                shortestDistance = distance;
                                connection.setAttribute('x1', motherConnectionNodes[i].x);
                                connection.setAttribute('y1', motherConnectionNodes[i].y);
                                connection.setAttribute('x2', connectionNodes[j].x);
                                connection.setAttribute('y2', connectionNodes[j].y);
                             }
                        }
                    }

                    connection.setAttribute("stroke", "gray");
                    connection.setAttribute("stroke-width", 1);
                    return connection;
            };

    }

    document.body.appendChild(svg);

        </script>
    </body>
</html>
